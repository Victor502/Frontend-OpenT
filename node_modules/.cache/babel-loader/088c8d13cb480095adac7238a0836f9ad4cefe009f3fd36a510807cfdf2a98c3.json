{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api';\nimport { AggregationTemporality, DataPointType } from '@opentelemetry/sdk-metrics';\nimport { hrTimeToFixed64Nanos } from '../common';\nimport { toAttributes } from '../common/internal';\nexport function toResourceMetrics(resourceMetrics) {\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics)\n  };\n}\nexport function toScopeMetrics(scopeMetrics) {\n  return Array.from(scopeMetrics.map(function (metrics) {\n    return {\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version\n      },\n      metrics: metrics.metrics.map(function (metricData) {\n        return toMetric(metricData);\n      }),\n      schemaUrl: metrics.scope.schemaUrl\n    };\n  }));\n}\nexport function toMetric(metricData) {\n  var out = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit\n  };\n  var aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality: aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData)\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData)\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData)\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality: aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData)\n      };\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoint(dataPoint, valueType) {\n  var out = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n    timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime)\n  };\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value;\n      break;\n  }\n  return out;\n}\nfunction toSingularDataPoints(metricData) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);\n  });\n}\nfunction toHistogramDataPoints(metricData) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n      timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime)\n    };\n  });\n}\nfunction toExponentialHistogramDataPoints(metricData) {\n  return metricData.dataPoints.map(function (dataPoint) {\n    var histogram = dataPoint.value;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n      timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime)\n    };\n  });\n}\nfunction toAggregationTemporality(temporality) {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return 1 /* AGGREGATION_TEMPORALITY_DELTA */;\n    case AggregationTemporality.CUMULATIVE:\n      return 2 /* AGGREGATION_TEMPORALITY_CUMULATIVE */;\n  }\n}","map":{"version":3,"names":["ValueType","AggregationTemporality","DataPointType","hrTimeToFixed64Nanos","toAttributes","toResourceMetrics","resourceMetrics","resource","attributes","droppedAttributesCount","schemaUrl","undefined","scopeMetrics","toScopeMetrics","Array","from","map","metrics","scope","name","version","metricData","toMetric","out","descriptor","description","unit","aggregationTemporality","toAggregationTemporality","dataPointType","SUM","sum","isMonotonic","dataPoints","toSingularDataPoints","GAUGE","gauge","HISTOGRAM","histogram","toHistogramDataPoints","EXPONENTIAL_HISTOGRAM","exponentialHistogram","toExponentialHistogramDataPoints","toSingularDataPoint","dataPoint","valueType","startTimeUnixNano","startTime","timeUnixNano","endTime","INT","asInt","value","DOUBLE","asDouble","bucketCounts","buckets","counts","explicitBounds","boundaries","count","min","max","positive","offset","negative","scale","zeroCount","temporality","DELTA","CUMULATIVE"],"sources":["/Users/victorhorton/Code/openTelemettry/front-end/node_modules/@opentelemetry/otlp-transformer/src/metrics/internal.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  ExponentialHistogram,\n  Histogram,\n  MetricData,\n  ResourceMetrics,\n  ScopeMetrics,\n} from '@opentelemetry/sdk-metrics';\nimport { hrTimeToFixed64Nanos } from '../common';\nimport { toAttributes } from '../common/internal';\nimport {\n  EAggregationTemporality,\n  IExponentialHistogramDataPoint,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics,\n} from './types';\n\nexport function toResourceMetrics(\n  resourceMetrics: ResourceMetrics\n): IResourceMetrics {\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0,\n    },\n    schemaUrl: undefined,\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics),\n  };\n}\n\nexport function toScopeMetrics(scopeMetrics: ScopeMetrics[]): IScopeMetrics[] {\n  return Array.from(\n    scopeMetrics.map(metrics => ({\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version,\n      },\n      metrics: metrics.metrics.map(metricData => toMetric(metricData)),\n      schemaUrl: metrics.scope.schemaUrl,\n    }))\n  );\n}\n\nexport function toMetric(metricData: MetricData): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(\n    metricData.aggregationTemporality\n  );\n\n  switch (metricData.dataPointType) {\n    case DataPointType.SUM:\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic: metricData.isMonotonic,\n        dataPoints: toSingularDataPoints(metricData),\n      };\n      break;\n    case DataPointType.GAUGE:\n      out.gauge = {\n        dataPoints: toSingularDataPoints(metricData),\n      };\n      break;\n    case DataPointType.HISTOGRAM:\n      out.histogram = {\n        aggregationTemporality,\n        dataPoints: toHistogramDataPoints(metricData),\n      };\n      break;\n    case DataPointType.EXPONENTIAL_HISTOGRAM:\n      out.exponentialHistogram = {\n        aggregationTemporality,\n        dataPoints: toExponentialHistogramDataPoints(metricData),\n      };\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(\n  dataPoint:\n    | DataPoint<number>\n    | DataPoint<Histogram>\n    | DataPoint<ExponentialHistogram>,\n  valueType: ValueType\n) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n    timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime),\n  };\n\n  switch (valueType) {\n    case ValueType.INT:\n      out.asInt = dataPoint.value as number;\n      break;\n    case ValueType.DOUBLE:\n      out.asDouble = dataPoint.value as number;\n      break;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(metricData: MetricData): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);\n  });\n}\n\nfunction toHistogramDataPoints(metricData: MetricData): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.min,\n      max: histogram.max,\n      startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n      timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toExponentialHistogramDataPoints(\n  metricData: MetricData\n): IExponentialHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as ExponentialHistogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      count: histogram.count,\n      min: histogram.min,\n      max: histogram.max,\n      sum: histogram.sum,\n      positive: {\n        offset: histogram.positive.offset,\n        bucketCounts: histogram.positive.bucketCounts,\n      },\n      negative: {\n        offset: histogram.negative.offset,\n        bucketCounts: histogram.negative.bucketCounts,\n      },\n      scale: histogram.scale,\n      zeroCount: histogram.zeroCount,\n      startTimeUnixNano: hrTimeToFixed64Nanos(dataPoint.startTime),\n      timeUnixNano: hrTimeToFixed64Nanos(dataPoint.endTime),\n    };\n  });\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality\n): EAggregationTemporality {\n  switch (temporality) {\n    case AggregationTemporality.DELTA:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n    case AggregationTemporality.CUMULATIVE:\n      return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,SAASA,SAAS,QAAQ,oBAAoB;AAC9C,SACEC,sBAAsB,EAEtBC,aAAa,QAMR,4BAA4B;AACnC,SAASC,oBAAoB,QAAQ,WAAW;AAChD,SAASC,YAAY,QAAQ,oBAAoB;AAWjD,OAAM,SAAUC,iBAAiBA,CAC/BC,eAAgC;EAEhC,OAAO;IACLC,QAAQ,EAAE;MACRC,UAAU,EAAEJ,YAAY,CAACE,eAAe,CAACC,QAAQ,CAACC,UAAU,CAAC;MAC7DC,sBAAsB,EAAE;KACzB;IACDC,SAAS,EAAEC,SAAS;IACpBC,YAAY,EAAEC,cAAc,CAACP,eAAe,CAACM,YAAY;GAC1D;AACH;AAEA,OAAM,SAAUC,cAAcA,CAACD,YAA4B;EACzD,OAAOE,KAAK,CAACC,IAAI,CACfH,YAAY,CAACI,GAAG,CAAC,UAAAC,OAAO;IAAI,OAAC;MAC3BC,KAAK,EAAE;QACLC,IAAI,EAAEF,OAAO,CAACC,KAAK,CAACC,IAAI;QACxBC,OAAO,EAAEH,OAAO,CAACC,KAAK,CAACE;OACxB;MACDH,OAAO,EAAEA,OAAO,CAACA,OAAO,CAACD,GAAG,CAAC,UAAAK,UAAU;QAAI,OAAAC,QAAQ,CAACD,UAAU,CAAC;MAApB,CAAoB,CAAC;MAChEX,SAAS,EAAEO,OAAO,CAACC,KAAK,CAACR;KAC1B;EAP2B,CAO1B,CAAC,CACJ;AACH;AAEA,OAAM,SAAUY,QAAQA,CAACD,UAAsB;EAC7C,IAAME,GAAG,GAAY;IACnBJ,IAAI,EAAEE,UAAU,CAACG,UAAU,CAACL,IAAI;IAChCM,WAAW,EAAEJ,UAAU,CAACG,UAAU,CAACC,WAAW;IAC9CC,IAAI,EAAEL,UAAU,CAACG,UAAU,CAACE;GAC7B;EAED,IAAMC,sBAAsB,GAAGC,wBAAwB,CACrDP,UAAU,CAACM,sBAAsB,CAClC;EAED,QAAQN,UAAU,CAACQ,aAAa;IAC9B,KAAK3B,aAAa,CAAC4B,GAAG;MACpBP,GAAG,CAACQ,GAAG,GAAG;QACRJ,sBAAsB,EAAAA,sBAAA;QACtBK,WAAW,EAAEX,UAAU,CAACW,WAAW;QACnCC,UAAU,EAAEC,oBAAoB,CAACb,UAAU;OAC5C;MACD;IACF,KAAKnB,aAAa,CAACiC,KAAK;MACtBZ,GAAG,CAACa,KAAK,GAAG;QACVH,UAAU,EAAEC,oBAAoB,CAACb,UAAU;OAC5C;MACD;IACF,KAAKnB,aAAa,CAACmC,SAAS;MAC1Bd,GAAG,CAACe,SAAS,GAAG;QACdX,sBAAsB,EAAAA,sBAAA;QACtBM,UAAU,EAAEM,qBAAqB,CAAClB,UAAU;OAC7C;MACD;IACF,KAAKnB,aAAa,CAACsC,qBAAqB;MACtCjB,GAAG,CAACkB,oBAAoB,GAAG;QACzBd,sBAAsB,EAAAA,sBAAA;QACtBM,UAAU,EAAES,gCAAgC,CAACrB,UAAU;OACxD;MACD;;EAGJ,OAAOE,GAAG;AACZ;AAEA,SAASoB,mBAAmBA,CAC1BC,SAGmC,EACnCC,SAAoB;EAEpB,IAAMtB,GAAG,GAAqB;IAC5Bf,UAAU,EAAEJ,YAAY,CAACwC,SAAS,CAACpC,UAAU,CAAC;IAC9CsC,iBAAiB,EAAE3C,oBAAoB,CAACyC,SAAS,CAACG,SAAS,CAAC;IAC5DC,YAAY,EAAE7C,oBAAoB,CAACyC,SAAS,CAACK,OAAO;GACrD;EAED,QAAQJ,SAAS;IACf,KAAK7C,SAAS,CAACkD,GAAG;MAChB3B,GAAG,CAAC4B,KAAK,GAAGP,SAAS,CAACQ,KAAe;MACrC;IACF,KAAKpD,SAAS,CAACqD,MAAM;MACnB9B,GAAG,CAAC+B,QAAQ,GAAGV,SAAS,CAACQ,KAAe;MACxC;;EAGJ,OAAO7B,GAAG;AACZ;AAEA,SAASW,oBAAoBA,CAACb,UAAsB;EAClD,OAAOA,UAAU,CAACY,UAAU,CAACjB,GAAG,CAAC,UAAA4B,SAAS;IACxC,OAAOD,mBAAmB,CAACC,SAAS,EAAEvB,UAAU,CAACG,UAAU,CAACqB,SAAS,CAAC;EACxE,CAAC,CAAC;AACJ;AAEA,SAASN,qBAAqBA,CAAClB,UAAsB;EACnD,OAAOA,UAAU,CAACY,UAAU,CAACjB,GAAG,CAAC,UAAA4B,SAAS;IACxC,IAAMN,SAAS,GAAGM,SAAS,CAACQ,KAAkB;IAC9C,OAAO;MACL5C,UAAU,EAAEJ,YAAY,CAACwC,SAAS,CAACpC,UAAU,CAAC;MAC9C+C,YAAY,EAAEjB,SAAS,CAACkB,OAAO,CAACC,MAAM;MACtCC,cAAc,EAAEpB,SAAS,CAACkB,OAAO,CAACG,UAAU;MAC5CC,KAAK,EAAEtB,SAAS,CAACsB,KAAK;MACtB7B,GAAG,EAAEO,SAAS,CAACP,GAAG;MAClB8B,GAAG,EAAEvB,SAAS,CAACuB,GAAG;MAClBC,GAAG,EAAExB,SAAS,CAACwB,GAAG;MAClBhB,iBAAiB,EAAE3C,oBAAoB,CAACyC,SAAS,CAACG,SAAS,CAAC;MAC5DC,YAAY,EAAE7C,oBAAoB,CAACyC,SAAS,CAACK,OAAO;KACrD;EACH,CAAC,CAAC;AACJ;AAEA,SAASP,gCAAgCA,CACvCrB,UAAsB;EAEtB,OAAOA,UAAU,CAACY,UAAU,CAACjB,GAAG,CAAC,UAAA4B,SAAS;IACxC,IAAMN,SAAS,GAAGM,SAAS,CAACQ,KAA6B;IACzD,OAAO;MACL5C,UAAU,EAAEJ,YAAY,CAACwC,SAAS,CAACpC,UAAU,CAAC;MAC9CoD,KAAK,EAAEtB,SAAS,CAACsB,KAAK;MACtBC,GAAG,EAAEvB,SAAS,CAACuB,GAAG;MAClBC,GAAG,EAAExB,SAAS,CAACwB,GAAG;MAClB/B,GAAG,EAAEO,SAAS,CAACP,GAAG;MAClBgC,QAAQ,EAAE;QACRC,MAAM,EAAE1B,SAAS,CAACyB,QAAQ,CAACC,MAAM;QACjCT,YAAY,EAAEjB,SAAS,CAACyB,QAAQ,CAACR;OAClC;MACDU,QAAQ,EAAE;QACRD,MAAM,EAAE1B,SAAS,CAAC2B,QAAQ,CAACD,MAAM;QACjCT,YAAY,EAAEjB,SAAS,CAAC2B,QAAQ,CAACV;OAClC;MACDW,KAAK,EAAE5B,SAAS,CAAC4B,KAAK;MACtBC,SAAS,EAAE7B,SAAS,CAAC6B,SAAS;MAC9BrB,iBAAiB,EAAE3C,oBAAoB,CAACyC,SAAS,CAACG,SAAS,CAAC;MAC5DC,YAAY,EAAE7C,oBAAoB,CAACyC,SAAS,CAACK,OAAO;KACrD;EACH,CAAC,CAAC;AACJ;AAEA,SAASrB,wBAAwBA,CAC/BwC,WAAmC;EAEnC,QAAQA,WAAW;IACjB,KAAKnE,sBAAsB,CAACoE,KAAK;MAC/B;IACF,KAAKpE,sBAAsB,CAACqE,UAAU;MACpC;;AAEN"},"metadata":{},"sourceType":"module","externalDependencies":[]}