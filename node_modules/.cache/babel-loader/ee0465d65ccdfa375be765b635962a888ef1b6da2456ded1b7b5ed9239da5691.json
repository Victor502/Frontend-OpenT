{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\nimport { isSpanContextValid, isValidSpanId, isValidTraceId, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nimport { B3_DEBUG_FLAG_KEY } from './common';\nimport { B3_CONTEXT_HEADER } from './constants';\nvar B3_CONTEXT_REGEX = /((?:[0-9a-f]{16}){1,2})-([0-9a-f]{16})(?:-([01d](?![0-9a-f])))?(?:-([0-9a-f]{16}))?/;\nvar PADDING = '0'.repeat(16);\nvar SAMPLED_VALUES = new Set(['d', '1']);\nvar DEBUG_STATE = 'd';\nfunction convertToTraceId128(traceId) {\n  return traceId.length === 32 ? traceId : \"\" + PADDING + traceId;\n}\nfunction convertToTraceFlags(samplingState) {\n  if (samplingState && SAMPLED_VALUES.has(samplingState)) {\n    return TraceFlags.SAMPLED;\n  }\n  return TraceFlags.NONE;\n}\n/**\n * Propagator for the B3 single-header HTTP format.\n * Based on: https://github.com/openzipkin/b3-propagation\n */\nvar B3SinglePropagator = /** @class */function () {\n  function B3SinglePropagator() {}\n  B3SinglePropagator.prototype.inject = function (context, carrier, setter) {\n    var spanContext = trace.getSpanContext(context);\n    if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context)) return;\n    var samplingState = context.getValue(B3_DEBUG_FLAG_KEY) || spanContext.traceFlags & 0x1;\n    var value = spanContext.traceId + \"-\" + spanContext.spanId + \"-\" + samplingState;\n    setter.set(carrier, B3_CONTEXT_HEADER, value);\n  };\n  B3SinglePropagator.prototype.extract = function (context, carrier, getter) {\n    var header = getter.get(carrier, B3_CONTEXT_HEADER);\n    var b3Context = Array.isArray(header) ? header[0] : header;\n    if (typeof b3Context !== 'string') return context;\n    var match = b3Context.match(B3_CONTEXT_REGEX);\n    if (!match) return context;\n    var _a = __read(match, 4),\n      extractedTraceId = _a[1],\n      spanId = _a[2],\n      samplingState = _a[3];\n    var traceId = convertToTraceId128(extractedTraceId);\n    if (!isValidTraceId(traceId) || !isValidSpanId(spanId)) return context;\n    var traceFlags = convertToTraceFlags(samplingState);\n    if (samplingState === DEBUG_STATE) {\n      context = context.setValue(B3_DEBUG_FLAG_KEY, samplingState);\n    }\n    return trace.setSpanContext(context, {\n      traceId: traceId,\n      spanId: spanId,\n      isRemote: true,\n      traceFlags: traceFlags\n    });\n  };\n  B3SinglePropagator.prototype.fields = function () {\n    return [B3_CONTEXT_HEADER];\n  };\n  return B3SinglePropagator;\n}();\nexport { B3SinglePropagator };","map":{"version":3,"names":["isSpanContextValid","isValidSpanId","isValidTraceId","trace","TraceFlags","isTracingSuppressed","B3_DEBUG_FLAG_KEY","B3_CONTEXT_HEADER","B3_CONTEXT_REGEX","PADDING","repeat","SAMPLED_VALUES","Set","DEBUG_STATE","convertToTraceId128","traceId","length","convertToTraceFlags","samplingState","has","SAMPLED","NONE","B3SinglePropagator","prototype","inject","context","carrier","setter","spanContext","getSpanContext","getValue","traceFlags","value","spanId","set","extract","getter","header","get","b3Context","Array","isArray","match","_a","__read","extractedTraceId","setValue","setSpanContext","isRemote","fields"],"sources":["/Users/victorhorton/Code/openTelemettry/front-end/node_modules/@opentelemetry/propagator-b3/src/B3SinglePropagator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  isValidSpanId,\n  isValidTraceId,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n  trace,\n  TraceFlags,\n} from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nimport { B3_DEBUG_FLAG_KEY } from './common';\nimport { B3_CONTEXT_HEADER } from './constants';\n\nconst B3_CONTEXT_REGEX =\n  /((?:[0-9a-f]{16}){1,2})-([0-9a-f]{16})(?:-([01d](?![0-9a-f])))?(?:-([0-9a-f]{16}))?/;\nconst PADDING = '0'.repeat(16);\nconst SAMPLED_VALUES = new Set(['d', '1']);\nconst DEBUG_STATE = 'd';\n\nfunction convertToTraceId128(traceId: string): string {\n  return traceId.length === 32 ? traceId : `${PADDING}${traceId}`;\n}\n\nfunction convertToTraceFlags(samplingState: string | undefined): TraceFlags {\n  if (samplingState && SAMPLED_VALUES.has(samplingState)) {\n    return TraceFlags.SAMPLED;\n  }\n  return TraceFlags.NONE;\n}\n\n/**\n * Propagator for the B3 single-header HTTP format.\n * Based on: https://github.com/openzipkin/b3-propagation\n */\nexport class B3SinglePropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const spanContext = trace.getSpanContext(context);\n    if (\n      !spanContext ||\n      !isSpanContextValid(spanContext) ||\n      isTracingSuppressed(context)\n    )\n      return;\n\n    const samplingState =\n      context.getValue(B3_DEBUG_FLAG_KEY) || spanContext.traceFlags & 0x1;\n    const value = `${spanContext.traceId}-${spanContext.spanId}-${samplingState}`;\n    setter.set(carrier, B3_CONTEXT_HEADER, value);\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const header = getter.get(carrier, B3_CONTEXT_HEADER);\n    const b3Context = Array.isArray(header) ? header[0] : header;\n    if (typeof b3Context !== 'string') return context;\n\n    const match = b3Context.match(B3_CONTEXT_REGEX);\n    if (!match) return context;\n\n    const [, extractedTraceId, spanId, samplingState] = match;\n    const traceId = convertToTraceId128(extractedTraceId);\n\n    if (!isValidTraceId(traceId) || !isValidSpanId(spanId)) return context;\n\n    const traceFlags = convertToTraceFlags(samplingState);\n\n    if (samplingState === DEBUG_STATE) {\n      context = context.setValue(B3_DEBUG_FLAG_KEY, samplingState);\n    }\n\n    return trace.setSpanContext(context, {\n      traceId,\n      spanId,\n      isRemote: true,\n      traceFlags,\n    });\n  }\n\n  fields(): string[] {\n    return [B3_CONTEXT_HEADER];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}