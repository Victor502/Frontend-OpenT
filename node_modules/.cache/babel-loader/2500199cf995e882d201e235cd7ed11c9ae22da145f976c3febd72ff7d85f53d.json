{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { isSpanContextValid, isValidSpanId, isValidTraceId, trace, TraceFlags } from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nimport { B3_DEBUG_FLAG_KEY } from './common';\nimport { X_B3_FLAGS, X_B3_PARENT_SPAN_ID, X_B3_SAMPLED, X_B3_SPAN_ID, X_B3_TRACE_ID } from './constants';\nvar VALID_SAMPLED_VALUES = new Set([true, 'true', 'True', '1', 1]);\nvar VALID_UNSAMPLED_VALUES = new Set([false, 'false', 'False', '0', 0]);\nfunction isValidSampledValue(sampled) {\n  return sampled === TraceFlags.SAMPLED || sampled === TraceFlags.NONE;\n}\nfunction parseHeader(header) {\n  return Array.isArray(header) ? header[0] : header;\n}\nfunction getHeaderValue(carrier, getter, key) {\n  var header = getter.get(carrier, key);\n  return parseHeader(header);\n}\nfunction getTraceId(carrier, getter) {\n  var traceId = getHeaderValue(carrier, getter, X_B3_TRACE_ID);\n  if (typeof traceId === 'string') {\n    return traceId.padStart(32, '0');\n  }\n  return '';\n}\nfunction getSpanId(carrier, getter) {\n  var spanId = getHeaderValue(carrier, getter, X_B3_SPAN_ID);\n  if (typeof spanId === 'string') {\n    return spanId;\n  }\n  return '';\n}\nfunction getDebug(carrier, getter) {\n  var debug = getHeaderValue(carrier, getter, X_B3_FLAGS);\n  return debug === '1' ? '1' : undefined;\n}\nfunction getTraceFlags(carrier, getter) {\n  var traceFlags = getHeaderValue(carrier, getter, X_B3_SAMPLED);\n  var debug = getDebug(carrier, getter);\n  if (debug === '1' || VALID_SAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.SAMPLED;\n  }\n  if (traceFlags === undefined || VALID_UNSAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.NONE;\n  }\n  // This indicates to isValidSampledValue that this is not valid\n  return;\n}\n/**\n * Propagator for the B3 multiple-header HTTP format.\n * Based on: https://github.com/openzipkin/b3-propagation\n */\nvar B3MultiPropagator = /** @class */function () {\n  function B3MultiPropagator() {}\n  B3MultiPropagator.prototype.inject = function (context, carrier, setter) {\n    var spanContext = trace.getSpanContext(context);\n    if (!spanContext || !isSpanContextValid(spanContext) || isTracingSuppressed(context)) return;\n    var debug = context.getValue(B3_DEBUG_FLAG_KEY);\n    setter.set(carrier, X_B3_TRACE_ID, spanContext.traceId);\n    setter.set(carrier, X_B3_SPAN_ID, spanContext.spanId);\n    // According to the B3 spec, if the debug flag is set,\n    // the sampled flag shouldn't be propagated as well.\n    if (debug === '1') {\n      setter.set(carrier, X_B3_FLAGS, debug);\n    } else if (spanContext.traceFlags !== undefined) {\n      // We set the header only if there is an existing sampling decision.\n      // Otherwise we will omit it => Absent.\n      setter.set(carrier, X_B3_SAMPLED, (TraceFlags.SAMPLED & spanContext.traceFlags) === TraceFlags.SAMPLED ? '1' : '0');\n    }\n  };\n  B3MultiPropagator.prototype.extract = function (context, carrier, getter) {\n    var traceId = getTraceId(carrier, getter);\n    var spanId = getSpanId(carrier, getter);\n    var traceFlags = getTraceFlags(carrier, getter);\n    var debug = getDebug(carrier, getter);\n    if (isValidTraceId(traceId) && isValidSpanId(spanId) && isValidSampledValue(traceFlags)) {\n      context = context.setValue(B3_DEBUG_FLAG_KEY, debug);\n      return trace.setSpanContext(context, {\n        traceId: traceId,\n        spanId: spanId,\n        isRemote: true,\n        traceFlags: traceFlags\n      });\n    }\n    return context;\n  };\n  B3MultiPropagator.prototype.fields = function () {\n    return [X_B3_TRACE_ID, X_B3_SPAN_ID, X_B3_FLAGS, X_B3_SAMPLED, X_B3_PARENT_SPAN_ID];\n  };\n  return B3MultiPropagator;\n}();\nexport { B3MultiPropagator };","map":{"version":3,"names":["isSpanContextValid","isValidSpanId","isValidTraceId","trace","TraceFlags","isTracingSuppressed","B3_DEBUG_FLAG_KEY","X_B3_FLAGS","X_B3_PARENT_SPAN_ID","X_B3_SAMPLED","X_B3_SPAN_ID","X_B3_TRACE_ID","VALID_SAMPLED_VALUES","Set","VALID_UNSAMPLED_VALUES","isValidSampledValue","sampled","SAMPLED","NONE","parseHeader","header","Array","isArray","getHeaderValue","carrier","getter","key","get","getTraceId","traceId","padStart","getSpanId","spanId","getDebug","debug","undefined","getTraceFlags","traceFlags","has","B3MultiPropagator","prototype","inject","context","setter","spanContext","getSpanContext","getValue","set","extract","setValue","setSpanContext","isRemote","fields"],"sources":["/Users/victorhorton/Code/openTelemettry/front-end/node_modules/@opentelemetry/propagator-b3/src/B3MultiPropagator.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  Context,\n  isSpanContextValid,\n  isValidSpanId,\n  isValidTraceId,\n  trace,\n  TextMapGetter,\n  TextMapPropagator,\n  TextMapSetter,\n  TraceFlags,\n} from '@opentelemetry/api';\nimport { isTracingSuppressed } from '@opentelemetry/core';\nimport { B3_DEBUG_FLAG_KEY } from './common';\nimport {\n  X_B3_FLAGS,\n  X_B3_PARENT_SPAN_ID,\n  X_B3_SAMPLED,\n  X_B3_SPAN_ID,\n  X_B3_TRACE_ID,\n} from './constants';\n\nconst VALID_SAMPLED_VALUES = new Set([true, 'true', 'True', '1', 1]);\nconst VALID_UNSAMPLED_VALUES = new Set([false, 'false', 'False', '0', 0]);\n\nfunction isValidSampledValue(sampled: TraceFlags | undefined): boolean {\n  return sampled === TraceFlags.SAMPLED || sampled === TraceFlags.NONE;\n}\n\nfunction parseHeader(header: unknown) {\n  return Array.isArray(header) ? header[0] : header;\n}\n\nfunction getHeaderValue(carrier: unknown, getter: TextMapGetter, key: string) {\n  const header = getter.get(carrier, key);\n  return parseHeader(header);\n}\n\nfunction getTraceId(carrier: unknown, getter: TextMapGetter): string {\n  const traceId = getHeaderValue(carrier, getter, X_B3_TRACE_ID);\n  if (typeof traceId === 'string') {\n    return traceId.padStart(32, '0');\n  }\n  return '';\n}\n\nfunction getSpanId(carrier: unknown, getter: TextMapGetter): string {\n  const spanId = getHeaderValue(carrier, getter, X_B3_SPAN_ID);\n  if (typeof spanId === 'string') {\n    return spanId;\n  }\n  return '';\n}\n\nfunction getDebug(carrier: unknown, getter: TextMapGetter): string | undefined {\n  const debug = getHeaderValue(carrier, getter, X_B3_FLAGS);\n  return debug === '1' ? '1' : undefined;\n}\n\nfunction getTraceFlags(\n  carrier: unknown,\n  getter: TextMapGetter\n): TraceFlags | undefined {\n  const traceFlags = getHeaderValue(carrier, getter, X_B3_SAMPLED);\n  const debug = getDebug(carrier, getter);\n  if (debug === '1' || VALID_SAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.SAMPLED;\n  }\n  if (traceFlags === undefined || VALID_UNSAMPLED_VALUES.has(traceFlags)) {\n    return TraceFlags.NONE;\n  }\n  // This indicates to isValidSampledValue that this is not valid\n  return;\n}\n\n/**\n * Propagator for the B3 multiple-header HTTP format.\n * Based on: https://github.com/openzipkin/b3-propagation\n */\nexport class B3MultiPropagator implements TextMapPropagator {\n  inject(context: Context, carrier: unknown, setter: TextMapSetter): void {\n    const spanContext = trace.getSpanContext(context);\n    if (\n      !spanContext ||\n      !isSpanContextValid(spanContext) ||\n      isTracingSuppressed(context)\n    )\n      return;\n\n    const debug = context.getValue(B3_DEBUG_FLAG_KEY);\n    setter.set(carrier, X_B3_TRACE_ID, spanContext.traceId);\n    setter.set(carrier, X_B3_SPAN_ID, spanContext.spanId);\n    // According to the B3 spec, if the debug flag is set,\n    // the sampled flag shouldn't be propagated as well.\n    if (debug === '1') {\n      setter.set(carrier, X_B3_FLAGS, debug);\n    } else if (spanContext.traceFlags !== undefined) {\n      // We set the header only if there is an existing sampling decision.\n      // Otherwise we will omit it => Absent.\n      setter.set(\n        carrier,\n        X_B3_SAMPLED,\n        (TraceFlags.SAMPLED & spanContext.traceFlags) === TraceFlags.SAMPLED\n          ? '1'\n          : '0'\n      );\n    }\n  }\n\n  extract(context: Context, carrier: unknown, getter: TextMapGetter): Context {\n    const traceId = getTraceId(carrier, getter);\n    const spanId = getSpanId(carrier, getter);\n    const traceFlags = getTraceFlags(carrier, getter) as TraceFlags;\n    const debug = getDebug(carrier, getter);\n\n    if (\n      isValidTraceId(traceId) &&\n      isValidSpanId(spanId) &&\n      isValidSampledValue(traceFlags)\n    ) {\n      context = context.setValue(B3_DEBUG_FLAG_KEY, debug);\n      return trace.setSpanContext(context, {\n        traceId,\n        spanId,\n        isRemote: true,\n        traceFlags,\n      });\n    }\n    return context;\n  }\n\n  fields(): string[] {\n    return [\n      X_B3_TRACE_ID,\n      X_B3_SPAN_ID,\n      X_B3_FLAGS,\n      X_B3_SAMPLED,\n      X_B3_PARENT_SPAN_ID,\n    ];\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}