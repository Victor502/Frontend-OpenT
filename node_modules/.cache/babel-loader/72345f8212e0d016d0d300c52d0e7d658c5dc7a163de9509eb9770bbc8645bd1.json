{"ast":null,"code":"/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag, ValueType } from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument } from './Instruments';\n/**\n * The class implements {@link ObservableResult} interface.\n */\nvar ObservableResultImpl = /** @class */function () {\n  function ObservableResultImpl(_descriptor) {\n    this._descriptor = _descriptor;\n    /**\n     * @internal\n     */\n    this._buffer = new AttributeHashMap();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  ObservableResultImpl.prototype.observe = function (value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (typeof value !== 'number') {\n      diag.warn(\"non-number value provided to metric \" + this._descriptor.name + \": \" + value);\n      return;\n    }\n    if (this._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\"INT value type cannot accept a floating-point value for \" + this._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._buffer.set(attributes, value);\n  };\n  return ObservableResultImpl;\n}();\nexport { ObservableResultImpl };\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nvar BatchObservableResultImpl = /** @class */function () {\n  function BatchObservableResultImpl() {\n    /**\n     * @internal\n     */\n    this._buffer = new Map();\n  }\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  BatchObservableResultImpl.prototype.observe = function (metric, value, attributes) {\n    if (attributes === void 0) {\n      attributes = {};\n    }\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    var map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (typeof value !== 'number') {\n      diag.warn(\"non-number value provided to metric \" + metric._descriptor.name + \": \" + value);\n      return;\n    }\n    if (metric._descriptor.valueType === ValueType.INT && !Number.isInteger(value)) {\n      diag.warn(\"INT value type cannot accept a floating-point value for \" + metric._descriptor.name + \", ignoring the fractional digits.\");\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    map.set(attributes, value);\n  };\n  return BatchObservableResultImpl;\n}();\nexport { BatchObservableResultImpl };","map":{"version":3,"names":["diag","ValueType","AttributeHashMap","isObservableInstrument","ObservableResultImpl","_descriptor","_buffer","prototype","observe","value","attributes","warn","name","valueType","INT","Number","isInteger","Math","trunc","set","BatchObservableResultImpl","Map","metric","map","get"],"sources":["/Users/victorhorton/Code/openTelemettry/front-end/node_modules/@opentelemetry/sdk-metrics/src/ObservableResult.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  diag,\n  ObservableResult,\n  MetricAttributes,\n  ValueType,\n  BatchObservableResult,\n  Observable,\n} from '@opentelemetry/api';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument, ObservableInstrument } from './Instruments';\nimport { InstrumentDescriptor } from '.';\n\n/**\n * The class implements {@link ObservableResult} interface.\n */\nexport class ObservableResultImpl implements ObservableResult {\n  /**\n   * @internal\n   */\n  _buffer = new AttributeHashMap<number>();\n\n  constructor(private _descriptor: InstrumentDescriptor) {}\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(value: number, attributes: MetricAttributes = {}): void {\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${this._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      this._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    this._buffer.set(attributes, value);\n  }\n}\n\n/**\n * The class implements {@link BatchObservableCallback} interface.\n */\nexport class BatchObservableResultImpl implements BatchObservableResult {\n  /**\n   * @internal\n   */\n  _buffer: Map<ObservableInstrument, AttributeHashMap<number>> = new Map();\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(\n    metric: Observable,\n    value: number,\n    attributes: MetricAttributes = {}\n  ): void {\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    let map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (typeof value !== 'number') {\n      diag.warn(\n        `non-number value provided to metric ${metric._descriptor.name}: ${value}`\n      );\n      return;\n    }\n    if (\n      metric._descriptor.valueType === ValueType.INT &&\n      !Number.isInteger(value)\n    ) {\n      diag.warn(\n        `INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n      // ignore non-finite values.\n      if (!Number.isInteger(value)) {\n        return;\n      }\n    }\n    map.set(attributes, value);\n  }\n}\n"],"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SACEA,IAAI,EAGJC,SAAS,QAGJ,oBAAoB;AAC3B,SAASC,gBAAgB,QAAQ,iBAAiB;AAClD,SAASC,sBAAsB,QAA8B,eAAe;AAG5E;;;AAGA,IAAAC,oBAAA;EAME,SAAAA,qBAAoBC,WAAiC;IAAjC,KAAAA,WAAW,GAAXA,WAAW;IAL/B;;;IAGA,KAAAC,OAAO,GAAG,IAAIJ,gBAAgB,EAAU;EAEgB;EAExD;;;EAGAE,oBAAA,CAAAG,SAAA,CAAAC,OAAO,GAAP,UAAQC,KAAa,EAAEC,UAAiC;IAAjC,IAAAA,UAAA;MAAAA,UAAA,KAAiC;IAAA;IACtD,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;MAC7BT,IAAI,CAACW,IAAI,CACP,yCAAuC,IAAI,CAACN,WAAW,CAACO,IAAI,UAAKH,KAAO,CACzE;MACD;;IAEF,IACE,IAAI,CAACJ,WAAW,CAACQ,SAAS,KAAKZ,SAAS,CAACa,GAAG,IAC5C,CAACC,MAAM,CAACC,SAAS,CAACP,KAAK,CAAC,EACxB;MACAT,IAAI,CAACW,IAAI,CACP,6DAA2D,IAAI,CAACN,WAAW,CAACO,IAAI,sCAAmC,CACpH;MACDH,KAAK,GAAGQ,IAAI,CAACC,KAAK,CAACT,KAAK,CAAC;MACzB;MACA,IAAI,CAACM,MAAM,CAACC,SAAS,CAACP,KAAK,CAAC,EAAE;QAC5B;;;IAGJ,IAAI,CAACH,OAAO,CAACa,GAAG,CAACT,UAAU,EAAED,KAAK,CAAC;EACrC,CAAC;EACH,OAAAL,oBAAC;AAAD,CAAC,CAjCD;;AAmCA;;;AAGA,IAAAgB,yBAAA;EAAA,SAAAA,0BAAA;IACE;;;IAGA,KAAAd,OAAO,GAAwD,IAAIe,GAAG,EAAE;EAuC1E;EArCE;;;EAGAD,yBAAA,CAAAb,SAAA,CAAAC,OAAO,GAAP,UACEc,MAAkB,EAClBb,KAAa,EACbC,UAAiC;IAAjC,IAAAA,UAAA;MAAAA,UAAA,KAAiC;IAAA;IAEjC,IAAI,CAACP,sBAAsB,CAACmB,MAAM,CAAC,EAAE;MACnC;;IAEF,IAAIC,GAAG,GAAG,IAAI,CAACjB,OAAO,CAACkB,GAAG,CAACF,MAAM,CAAC;IAClC,IAAIC,GAAG,IAAI,IAAI,EAAE;MACfA,GAAG,GAAG,IAAIrB,gBAAgB,EAAE;MAC5B,IAAI,CAACI,OAAO,CAACa,GAAG,CAACG,MAAM,EAAEC,GAAG,CAAC;;IAE/B,IAAI,OAAOd,KAAK,KAAK,QAAQ,EAAE;MAC7BT,IAAI,CAACW,IAAI,CACP,yCAAuCW,MAAM,CAACjB,WAAW,CAACO,IAAI,UAAKH,KAAO,CAC3E;MACD;;IAEF,IACEa,MAAM,CAACjB,WAAW,CAACQ,SAAS,KAAKZ,SAAS,CAACa,GAAG,IAC9C,CAACC,MAAM,CAACC,SAAS,CAACP,KAAK,CAAC,EACxB;MACAT,IAAI,CAACW,IAAI,CACP,6DAA2DW,MAAM,CAACjB,WAAW,CAACO,IAAI,sCAAmC,CACtH;MACDH,KAAK,GAAGQ,IAAI,CAACC,KAAK,CAACT,KAAK,CAAC;MACzB;MACA,IAAI,CAACM,MAAM,CAACC,SAAS,CAACP,KAAK,CAAC,EAAE;QAC5B;;;IAGJc,GAAG,CAACJ,GAAG,CAACT,UAAU,EAAED,KAAK,CAAC;EAC5B,CAAC;EACH,OAAAW,yBAAC;AAAD,CAAC,CA3CD"},"metadata":{},"sourceType":"module","externalDependencies":[]}