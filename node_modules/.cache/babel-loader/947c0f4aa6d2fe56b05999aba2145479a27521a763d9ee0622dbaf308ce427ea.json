{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n    r,\n    ar = [],\n    e;\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n  return ar;\n};\n/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { OTLPExporterError } from '../../types';\nimport { DEFAULT_EXPORT_MAX_ATTEMPTS, DEFAULT_EXPORT_INITIAL_BACKOFF, DEFAULT_EXPORT_BACKOFF_MULTIPLIER, DEFAULT_EXPORT_MAX_BACKOFF, isExportRetryable, parseRetryAfterToMills } from '../../util';\n/**\n * Send metrics/spans using browser navigator.sendBeacon\n * @param body\n * @param url\n * @param blobPropertyBag\n * @param onSuccess\n * @param onError\n */\nexport function sendWithBeacon(body, url, blobPropertyBag, onSuccess, onError) {\n  if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {\n    diag.debug('sendBeacon - can send', body);\n    onSuccess();\n  } else {\n    var error = new OTLPExporterError(\"sendBeacon - cannot send \" + body);\n    onError(error);\n  }\n}\n/**\n * function to send metrics/spans using browser XMLHttpRequest\n *     used when navigator.sendBeacon is not available\n * @param body\n * @param url\n * @param headers\n * @param onSuccess\n * @param onError\n */\nexport function sendWithXhr(body, url, headers, exporterTimeout, onSuccess, onError) {\n  var retryTimer;\n  var xhr;\n  var reqIsDestroyed = false;\n  var exporterTimer = setTimeout(function () {\n    clearTimeout(retryTimer);\n    reqIsDestroyed = true;\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      var err = new OTLPExporterError('Request Timeout');\n      onError(err);\n    } else {\n      xhr.abort();\n    }\n  }, exporterTimeout);\n  var sendWithRetry = function (retries, minDelay) {\n    if (retries === void 0) {\n      retries = DEFAULT_EXPORT_MAX_ATTEMPTS;\n    }\n    if (minDelay === void 0) {\n      minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF;\n    }\n    xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n    var defaultHeaders = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json'\n    };\n    Object.entries(__assign(__assign({}, defaultHeaders), headers)).forEach(function (_a) {\n      var _b = __read(_a, 2),\n        k = _b[0],\n        v = _b[1];\n      xhr.setRequestHeader(k, v);\n    });\n    xhr.send(body);\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          diag.debug('xhr success', body);\n          onSuccess();\n          clearTimeout(exporterTimer);\n          clearTimeout(retryTimer);\n        } else if (xhr.status && isExportRetryable(xhr.status) && retries > 0) {\n          var retryTime = void 0;\n          minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;\n          // retry after interval specified in Retry-After header\n          if (xhr.getResponseHeader('Retry-After')) {\n            retryTime = parseRetryAfterToMills(xhr.getResponseHeader('Retry-After'));\n          } else {\n            // exponential backoff with jitter\n            retryTime = Math.round(Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay);\n          }\n          retryTimer = setTimeout(function () {\n            sendWithRetry(retries - 1, minDelay);\n          }, retryTime);\n        } else {\n          var error = new OTLPExporterError(\"Failed to export with XHR (status: \" + xhr.status + \")\", xhr.status);\n          onError(error);\n          clearTimeout(exporterTimer);\n          clearTimeout(retryTimer);\n        }\n      }\n    };\n    xhr.onabort = function () {\n      if (reqIsDestroyed) {\n        var err = new OTLPExporterError('Request Timeout');\n        onError(err);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    };\n    xhr.onerror = function () {\n      if (reqIsDestroyed) {\n        var err = new OTLPExporterError('Request Timeout');\n        onError(err);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    };\n  };\n  sendWithRetry();\n}","map":{"version":3,"names":["diag","OTLPExporterError","DEFAULT_EXPORT_MAX_ATTEMPTS","DEFAULT_EXPORT_INITIAL_BACKOFF","DEFAULT_EXPORT_BACKOFF_MULTIPLIER","DEFAULT_EXPORT_MAX_BACKOFF","isExportRetryable","parseRetryAfterToMills","sendWithBeacon","body","url","blobPropertyBag","onSuccess","onError","navigator","sendBeacon","Blob","debug","error","sendWithXhr","headers","exporterTimeout","retryTimer","xhr","reqIsDestroyed","exporterTimer","setTimeout","clearTimeout","readyState","XMLHttpRequest","DONE","err","abort","sendWithRetry","retries","minDelay","open","defaultHeaders","Accept","Object","entries","__assign","forEach","_a","_b","__read","k","v","setRequestHeader","send","onreadystatechange","status","retryTime","getResponseHeader","Math","round","random","onabort","onerror"],"sources":["/Users/victorhorton/Code/openTelemettry/front-end/node_modules/@opentelemetry/otlp-exporter-base/src/platform/browser/util.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { OTLPExporterError } from '../../types';\nimport {\n  DEFAULT_EXPORT_MAX_ATTEMPTS,\n  DEFAULT_EXPORT_INITIAL_BACKOFF,\n  DEFAULT_EXPORT_BACKOFF_MULTIPLIER,\n  DEFAULT_EXPORT_MAX_BACKOFF,\n  isExportRetryable,\n  parseRetryAfterToMills,\n} from '../../util';\n\n/**\n * Send metrics/spans using browser navigator.sendBeacon\n * @param body\n * @param url\n * @param blobPropertyBag\n * @param onSuccess\n * @param onError\n */\nexport function sendWithBeacon(\n  body: string,\n  url: string,\n  blobPropertyBag: BlobPropertyBag,\n  onSuccess: () => void,\n  onError: (error: OTLPExporterError) => void\n): void {\n  if (navigator.sendBeacon(url, new Blob([body], blobPropertyBag))) {\n    diag.debug('sendBeacon - can send', body);\n    onSuccess();\n  } else {\n    const error = new OTLPExporterError(`sendBeacon - cannot send ${body}`);\n    onError(error);\n  }\n}\n\n/**\n * function to send metrics/spans using browser XMLHttpRequest\n *     used when navigator.sendBeacon is not available\n * @param body\n * @param url\n * @param headers\n * @param onSuccess\n * @param onError\n */\nexport function sendWithXhr(\n  body: string | Blob,\n  url: string,\n  headers: Record<string, string>,\n  exporterTimeout: number,\n  onSuccess: () => void,\n  onError: (error: OTLPExporterError) => void\n): void {\n  let retryTimer: ReturnType<typeof setTimeout>;\n  let xhr: XMLHttpRequest;\n  let reqIsDestroyed = false;\n\n  const exporterTimer = setTimeout(() => {\n    clearTimeout(retryTimer);\n    reqIsDestroyed = true;\n\n    if (xhr.readyState === XMLHttpRequest.DONE) {\n      const err = new OTLPExporterError('Request Timeout');\n      onError(err);\n    } else {\n      xhr.abort();\n    }\n  }, exporterTimeout);\n\n  const sendWithRetry = (\n    retries = DEFAULT_EXPORT_MAX_ATTEMPTS,\n    minDelay = DEFAULT_EXPORT_INITIAL_BACKOFF\n  ) => {\n    xhr = new XMLHttpRequest();\n    xhr.open('POST', url);\n\n    const defaultHeaders = {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n    };\n\n    Object.entries({\n      ...defaultHeaders,\n      ...headers,\n    }).forEach(([k, v]) => {\n      xhr.setRequestHeader(k, v);\n    });\n\n    xhr.send(body);\n\n    xhr.onreadystatechange = () => {\n      if (xhr.readyState === XMLHttpRequest.DONE && reqIsDestroyed === false) {\n        if (xhr.status >= 200 && xhr.status <= 299) {\n          diag.debug('xhr success', body);\n          onSuccess();\n          clearTimeout(exporterTimer);\n          clearTimeout(retryTimer);\n        } else if (xhr.status && isExportRetryable(xhr.status) && retries > 0) {\n          let retryTime: number;\n          minDelay = DEFAULT_EXPORT_BACKOFF_MULTIPLIER * minDelay;\n\n          // retry after interval specified in Retry-After header\n          if (xhr.getResponseHeader('Retry-After')) {\n            retryTime = parseRetryAfterToMills(\n              xhr.getResponseHeader('Retry-After')!\n            );\n          } else {\n            // exponential backoff with jitter\n            retryTime = Math.round(\n              Math.random() * (DEFAULT_EXPORT_MAX_BACKOFF - minDelay) + minDelay\n            );\n          }\n\n          retryTimer = setTimeout(() => {\n            sendWithRetry(retries - 1, minDelay);\n          }, retryTime);\n        } else {\n          const error = new OTLPExporterError(\n            `Failed to export with XHR (status: ${xhr.status})`,\n            xhr.status\n          );\n          onError(error);\n          clearTimeout(exporterTimer);\n          clearTimeout(retryTimer);\n        }\n      }\n    };\n\n    xhr.onabort = () => {\n      if (reqIsDestroyed) {\n        const err = new OTLPExporterError('Request Timeout');\n        onError(err);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    };\n\n    xhr.onerror = () => {\n      if (reqIsDestroyed) {\n        const err = new OTLPExporterError('Request Timeout');\n        onError(err);\n      }\n      clearTimeout(exporterTimer);\n      clearTimeout(retryTimer);\n    };\n  };\n\n  sendWithRetry();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}